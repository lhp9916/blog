---
title: 为什么我想成为一名全栈工程师
---

前面我就说过，我自学了很多方面的技术的，原因嘛就是我想成为一名全栈工程师。今天在网上看一到了这篇文章——《为什么你应该尝试“全栈”》，下面是文章内容，跟大家分享一下。

程序员看到"全栈"这个概念，大概会有两种反应<br>
1. 卧槽，这个好，碉堡了<br>
2. 你懂毛，全栈就是样样稀松<br>
以上两种反应其实都有失偏颇。因为即使只学一门技术，水平很菜的人也多的是，而全栈工程师当中样样都做，而样样都做得不错的也不少。更别说这个世界还存在另外一种爆栈型的程序员，做什么，什么都精。
从我的个人实践出发，全栈学徒至少要掌握以下几种技能：<br>
Web 前端开发，至少掌握一种前端框架；<br>
Server 后端开发，至少掌握一种后端框架；<br>
Server 运维，掌握 Linux Server 的搭建与维护；<br>
客户端开发，iOS 和 Android 至少掌握一种；<br>
数据库，掌握 SQL 和 noSQL 数据库。<br>
而获得全栈这个称谓则应该至少独当一面的一个人完成一款产品的构建，并且真的经历过商业化运作，以及，被自己的愚蠢坑过无数次。<br>
由此可见，全栈的门槛还是挺高的，并不是说掌握以上五种技能，就能称为全栈，至少要加个学徒来修饰一下，也正是因为太多学徒自诩全栈，才令旁人觉得"全栈"就是"样样稀松"的同义词。
不过，这篇文章的题目是 —— 为什么你应该尝试全栈，所以我想讨论的并不在要不要做全栈，而是尝试。

### 外行与内行
过去几年里，我和不少团队聊过，发现绝大部分的团队矛盾都在于——<br>
Server 端的不懂客户端，设计出来个 API 后瞎 BB；<br>
设计师不懂客户端，设计个交互瞎 BB；<br>
客户端不懂 Server，对着 API 瞎 BB；<br>
客户端不懂产品，对着需求瞎 BB；<br>
产品经理不懂需求，对着 Team 瞎 BB。<br>
除了最后的产品经理应该被烧死以外，前四个矛盾都还是有救的。

程序员是一个上帝模式的职业，每天的工作就是创造，所以这个职业看起来很酷。然而正因为如此，程序员多少都会有些自负，自负的结果就是以自己有限的知识去揣测别人的工作该怎么做。
如果 Server 端不懂客户端，那么很容易设计出来不符合客户端机制的 API。在这时候，做客户端那边的程序员耐心解释，每个 API 耽误一两天的时间来磨合还可以，不好的话就要吵架了。
但 Server 端的程序员并不总是错的，客户端这边希望所有数据给出来后不需要再加工，但往往按照客户端需要的结构給的话，有些查询可能要耗时一两秒。客户端如果不理解服务端的机制，一味以 "服务端就是給客户端服务的" 来要求，吵架就又难以避免了。
如果说技术人之间的争论是冷兵器战争的话，那如果碰到更外行的产品经理或者老板，那就要爆发核战争了。<br>
"你就改个网页，十分钟能搞定吗？"<br>
"效果怎么可能很难做，我给你做个！"<br>
"明天上线，赶紧的！"<br>
"我不管你技术上有什么难度，反正你就得给我实现出来！"<br>
而这样的场景，无论是哪家公司，几乎都在不停上演。<br>

### 尝试了解对方的技术
先聊聊我的技术成长轨迹吧。
我从初中开始使用 Linux，主力系统是 Ubuntu，而后切换到 ArchLinux，然后再回到 Ubuntu，一直使用到大一，这几年的 Linux 使用经验奠定了 Server 架构的基础，大一开始尝试自己做一款产品。
那时候就琢磨，我应该先写一个网页版，然后再写个客户端。
所以从后端开始，我使用 Django 作为起步，不过很快我转移到了 Rails 阵营，Rails 的敏捷开发极大的降低了开发成本，而其的约定习惯，也使得菜鸟能够平安飞过很多危险区域。
开始写网页前端的时候，并不知道有前端框架这个东西，直到用 Rails 写完了后才发现原来有东西叫 Ember.js，于是开始用 Ember.js 来重写，一开始的理解还是如何用 Rails 来渲染前端，后来发现其实在引入了前端框架后 Rails 的角色已经变成了个 API Server 了。
于是由此开始从新的角度去考虑如何设计 Rails 的 API，阅读了大量的 API 设计的资料，怎么样设计前端才好用，怎么样降低查询时间，服务器缓存，redis，安全等等。
Rails 的自动化帮了不少忙，很多自己并不知道的地方它已经帮忙做好，而当你想了解的时候，又会发现其实现是如此精妙。更别说 Rails 对新技术的接受程度，使得你总是有新东西可以玩，CoffeeScript 和 Sass 最早就是 Rails 吸收作为自己框架的默认前端技术。

随后由 Ember.js 又切换到 Angular.js，用 Angular 重写一遍，期间又接触了前端工具 Grunt （前端的变化一日千里，现在用的东西已经不是这个了）。
最后我开始开发 iOS 客户端，此时 iOS 的界面实现又与网页的 HTML 和 CSS 有着很多不同，所以我又花费了不少时间去理解 iOS 的 UI 概念，把思维从网页转换成 iOS 的界面开发思想。
数据库也在这个期间从 MySQL 换成了 MongoDB，因为那几年的潮流也正好是这个转变。
在这个技术实操的过程里幸好是我一个人，所以没人可以吵架，不然我想各个阶段都是有很多值得争吵的地方。
在我所开发的项目上线后，随着运维的复杂程度逐渐提升，也因此接触了 chef 和 Ansible 这种自动化运维方式，再往后 NewRelic 这类的监控服务也上了，而我为了一个稳定的开发环境，继而使用了 Vagrant。
这一切都只发生在一年的时间里。
有趣的是，很多时候我写着 iOS 客户端时，突然想明白了 HTML 和 CSS 的实现原理，做着 Rails 的时候，突然想出了更好的 iOS 架构方式，不同的技术之间触类旁通的感觉在每天都发生着。
在后来的时间里，这段经历使得我和不同的技术人沟通都非常轻松，因为去年秒视做滤镜的原因，我开始研究起 openGL，在重拾了 Blender之 后，很多以前似懂非懂的地方，实现突然变的像 Hello World 一样简单，因此也干脆玩起 Unity 来，在这一切的积累之后，Unity 的学习变的非常轻松，成为了我晚上的休闲项目，或许不久之后，你会看到一款我做的游戏（可能会是 RPG）。
我并不觉得全栈会使得你全面平庸，每种技术在做的时候都可以为其他的技术提供思路，而在你了解各种技术的前提下，深入其中的某个技术，时常能够带来对其他技术的反哺。相反，了解的技术如果非常狭隘，很可能才是限制自己潜能的原因。

### 尊重与和平
在团队沟通的时候，对对方技术的了解能减少非常多的沟通成本，并带来尊重和和平。
很少见大神在一起争论谁该来让步，相反往往都是初窥门径的人整天吵个没完，脾气一点就爆。
虽然很难讲整个行业的水平能很快有质的变化，但是我想如果产品需求能够详细的描述清楚，说清楚原因，技术人员之间能够在一起相互学习，耐心的探讨，设计师能够尊重技术纬度的事情，设计出更符合当下的原型，那一切就会往者好的方向发展，这一切就从了解对方的工作开始。<br>
（作者：周楷雯 原文地址：http://www.ifanr.com/551905）